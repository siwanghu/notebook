# Redis
<!-- TOC -->

- [Redis](#redis)
    - [数据类型](#数据类型)
    - [内部数据结构](#内部数据结构)
        - [实现原理](#实现原理)
        - [对应关系](#对应关系)
        - [dict](#dict)
        - [sds](#sds)
        - [ziplist](#ziplist)
        - [skiplist](#skiplist)
        - [intset](#intset)
    - [线程模型](#线程模型)
    - [事件驱动](#事件驱动)
    - [命令处理](#命令处理)
    - [持久化](#持久化)
        - [RDB](#rdb)
        - [AOF](#aof)
    - [事务](#事务)
        - [watch](#watch)
    - [集群](#集群)
    - [分布式锁](#分布式锁)
        - [单节点实现](#单节点实现)
        - [集群实现](#集群实现)
    - [其它事项](#其它事项)
        - [过期键删除策略](#过期键删除策略)
        - [内存淘汰策略](#内存淘汰策略)

<!-- /TOC -->
## 数据类型
+ string
+ list
+ set
+ sorted set
+ hash
## 内部数据结构  
### 实现原理
![redisObject](./pic/redisobject.png)  
+ Redis内部数据库使用dict维护key space到value space的映射关系，key space使用string类型，value space使用redisObject类型  
+ redisObject类型内部维护value的数据类型，使用的数据结构及数据指针指向真正的value存储位置等信息
### 对应关系
![type](./pic/type.png)
### dict  
+ dict是维护key到value映射关系的数据结构，与哈希表类似  
+ Redis数据库中存储所有key到value的映射关系使用dict维护
+ Hash数据类型中Field属性域较多时也是使用dict维护
+ dict使用拉链法解决hash冲突，装载因子超过预定值时引发重哈希
+ 重哈希过程采用增量式重哈希方法，避免过度消耗系统资源，造成Redis服务响应迟钝
  
![dict](./pic/dict.png)  
### sds  
+ Redis定义存储字符串的数据结构  
+ SDS是二进制安全的，既可以存储字符串也可以存储二进制文件
+ Redis采用空间预分配和惰性空间回收策略，避免对Redis性能造成影响
![sds](./pic/sds)
### ziplist  
+ Redis为节约内存设计的数据结构，由连续内存块组成的顺序型数据结构
+ 当list与hash只包含少量元素且元素值为小型整数或短字符串时，使用ziplist存储  
  
![ziplist](./pic/ziplist.jpg)
+ zlbytes&#160; &#160; 记录整个ziplist占用的总字节数
+ zltail&#160; &#160; 记录表尾节点相比ziplist起始位置的偏移量
+ zllen&#160; &#160; 记录ziplist包含的节点个数
+ entry&#160; &#160; ziplist包含的各个节点
+ zlend&#160; &#160;用于标记ziplist的尾端
### skiplist  
+ skiplist通过在每个节点维护多个指向其它节点的指针，达到快速访问节点的目的  
+ skiplist是sorted set的底层数据结构实现  
  
![skiplist](./pic/skiplist.jpg)
### intset  
+ intset是Redis中set的底层数据结构支持之一 
+ 当集合中元素数目不多，且只包含整数值时，使用intset实现set数据类型
  
![intset](./pic/intset.jpg)

## 线程模型
+ Redis使用IO多路复用模型  
> &#160; &#160; &#160; &#160;主线程同时监听多个Socket，每个Socket产生的事件会放入队列中排队，事件分配器每次从队列中取出一个事件，将事件分配到对应的事件处理器中处理  
+ Redis内部为保证跨平台，基于select与epoll实现了统一的事件处理机制，在编译时可选择采用何种IO多路复用机制  
  
![io](./pic/io.png)
## 事件驱动
+ Redis以单线程响应服务，利用IO多路复用机制，内部实现事件驱动机制
+ Redis内部事件分为timer定时事件与IO事件
+ Redis主线程事件驱动流程图  
  
<img src="./pic/main.webp" width = "400" height = "900" alt="图片名称" align=center />
  
+ 主函数启动时首先加载配置文件进行系统初始化  
+ 创建事件循环，开始Socket监听，同时向事件循环中注册timer定时事件
+ 事件循环启动后，首先查找最近的定时事件，过程中如果发生IO事件，则执行IO事件
+ IO事件执行完毕后，如果查找到定时事件，则执行定时事件  
## 命令处理  
> 由于Redis单线程的运行机制，Redis在执行以下时保证是原子性的操作  
> + 单个命令  
> + 事务  
> + lua脚本  
  
<img src="./pic/pross.png" width = "300" height = "700" alt="图片名称" align=center />
  
## 持久化
### RDB
+ Redis周期性的将当前时刻的内存快照写入rdb文件中  
+ 为避免RDB过程影响Redis性能，RDB会在子进程中运行  
+ fork的子进程与父进程共享内存代码段与数据段，当父进程收到修改指令时，采用Copy On Write机制，在复制的页面进行修改，保证子进程保存的内存数据是RDB开启时的内存数据  
+ 在配置文件中可以设置多少时间内发生键值的改变时，开始RDB
  
![rdb](./pic/rdb.png)  
### AOF
+ 通过记录对内存数据修改的指令来实现持久化  
+ 为避免磁盘写入操作影响性能，Redis并不会直接将指令追加到磁盘aof文件中，而是先写入缓冲区，由操作系统异步的写入磁盘  
+ 通过修改配置文件中appendfsync参数，指定异步写入是每秒写入，每条指令写入，还是由操作系统决定何时写入  
+ 为避免aof文件过大，Redis提供aof重写功能，开启后，会根据当前Redis内存数据创建新的aof文件替换旧的aof文件
## 事务
+ Redis事务不具备回滚，如果执行事务期间，发生错误，将继续执行事务中的Redis指令  
### watch  
+ 事务执行前，可以watch任意数据的键，如果被watch的键没有发生修改，则执行当前事务，否则事务将被拒绝执行  
+ watch命令的引入，可以看成是一个乐观锁  
> &#160; &#160; &#160; &#160;由于Redis执行事务是原子性的，Redis不会在一个Redis事务的执行过程中插入执行另一个客户端发出的请求。可以将资源操作定义为事务，将代表资源的锁看成被watch的变量，只要这个变量在事务执行之前没有被修改，则执行事务，完成资源的操作
## 集群
+ Redis使用分片的概念，整个划分为16384个slot，指定每个节点具体负责的slot(槽)  
+ 利用CRC16计算key属于的slot，从而存储到指定Redis节点中
> &#160; &#160; &#160; &#160; CRC16(key) & 16383  
+ 为保证整个集群的稳定性，可以给每个Redis节点配置主从结构，当Master宕机后，通过选举算法，将Slave提升为Master,以此提高集群的故障容灾能力
## 分布式锁
### 单节点实现  
+ 锁申请  
> &#160; &#160; &#160; &#160;SET keyName requestID NX PX ttl  
> + keyName&#160; &#160;锁的名字
> + requestID&#160; &#160;用户的请求ID
> + NX&#160; &#160;如果keyName不存在，添加成功，否则添加失败
> + PX&#160; &#160;设置过期时间
> + ttl&#160; &#160;具体的过期时间  
+ 锁释放
> &#160; &#160; &#160; &#160;锁释放需要先判断requestID是否等于当前的requestID，如果不是，说明锁因为过期时间到，被Redis删除之后，由其它请求申请到了。如果相等，则删除，整个过程需要原子性的操作，借助lua脚本实现  
+ 存在的问题  
> &#160; &#160; &#160; &#160;如果锁因为过期时间到被Redis释放，使得其它request获取到锁，违法了锁的互斥原则  
+ 解决方案  
> + 在分布式锁的申请实现中增加一个版本号，每次有request申请锁，锁版本号递增
> + 获取到锁的request在访问资源时，比较自己获取到的版本号与锁的版本号，如果小于锁的版本号，说明有其它request获取到锁，应立刻释放锁，并停止访问资源
### 集群实现  
+ RedLock算法  
> 1.	获取当前的时间戳S
> 2.	顺序依次向集群中的Redis实例申请相同的锁
> 3.	当成功在大于等于N/2+1的Redis实例上申请成功时，记录申请锁花费的时间
> 4.	如果申请锁花费的时间小于锁的持续时长，则锁申请成功
> 5.	返回申请成功的消息，锁的可用时间为锁的持续时间减去锁申请花费的时间
> 6.	如果不满足申请成功的条件，则在申请成功的Redis实例上执行锁释放的操作
## 其它事项  
### 过期键删除策略
+ 惰性删除  
> &#160; &#160; &#160; &#160;当客户端查询键时，根据查询的时间戳与键创建的时间戳来判断键是否过期，如果过期则删除，否则返回查询的键值。惰性删除会造成如果键未被查询，将无法被删除，占用的内存也无法被释放  
+ 定时删除  
> &#160; &#160; &#160; &#160;Redis会定时随机抽取一些键判断它是否过期，如果过期则删除。随机抽取一些键而非全盘扫描是为避免定时删除影响Redis的性能
### 内存淘汰策略
> 当出现内存不足时，Redis会采用内存淘汰策略，淘汰一些键，释放出内存空间，目前主要有以下几种策略：
+ volatile-lru：从已设置过期时间的键中，选择最近最少使用的键淘汰
+ volatile-ttl：从已设置过期时间的键中，选择快要过期的键淘汰
+ volatile-random：从已设置过期时间的键中，随机选择键淘汰
+ allkeys-lru：从所有键中，选择最近最少使用的键淘汰
+ allkeys-random：从所有键中，随机选择键淘汰  
+ no-eviction：当内存不足时，不淘汰键，直接禁止写入 **[很少使用]**  
  
[@SiwangHu](https://github.com/siwanghu)